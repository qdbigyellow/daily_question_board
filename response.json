{
  "timestamp": "2026-02-12 09:49:09 UTC",
  "response": "Here are three multiple-choice questions designed to meet your specifications:\n\n---\n\n### Question 1: AWS Architect (Intermediate Level)\n\n**Question:**\nA fast-growing e-commerce platform built on AWS currently runs its web application on a single Amazon EC2 instance and uses an Amazon RDS Multi-AZ PostgreSQL database. During peak traffic events, the application becomes unresponsive, and the single EC2 instance represents a critical single point of failure. The company wants to improve the architecture for high availability, scalability, and better performance without a complete re-architecture.\n\nWhich of the following *immediate* architectural changes would best address the current issues?\n\n**Answer Options:**\nA. Migrate the database to Amazon Aurora PostgreSQL and enable auto-scaling for read replicas.\nB. Place the existing EC2 instance behind an Application Load Balancer (ALB) and create an Auto Scaling Group (ASG) for the web application tier across multiple Availability Zones.\nC. Implement Amazon CloudFront for static content delivery and introduce Amazon ElastiCache for database query caching.\nD. Convert the EC2 instance to a larger instance type (e.g., c5.4xlarge) and enable detailed monitoring with CloudWatch.\n\n**Correct Answer:** B\n\n**Explanation:**\n*   **Correct (B):** This option directly addresses both the single point of failure and scalability issues of the application tier. An Application Load Balancer (ALB) distributes incoming traffic across multiple targets, improving responsiveness and acting as a single entry point. An Auto Scaling Group (ASG) automatically adjusts the number of EC2 instances based on demand and replaces unhealthy instances, ensuring high availability and elasticity. Spreading instances across multiple Availability Zones (AZs) further enhances fault tolerance. This is a fundamental and highly effective architectural pattern for web applications on AWS.\n*   **Incorrect (A):** While Amazon Aurora is an excellent, highly scalable database, the primary bottleneck described is the single EC2 instance for the *web application*. The existing RDS Multi-AZ PostgreSQL already provides high availability for the database. Migrating the database or adding read replicas would improve database performance and scalability, but wouldn't directly solve the application server's single point of failure or its inability to scale to meet web traffic demands.\n*   **Incorrect (C):** CloudFront (CDN) and ElastiCache (caching) are valuable services for improving performance and reducing the load on backend systems. However, they are optimizations that enhance user experience and offload traffic, but they do not solve the fundamental problem of the single EC2 instance being a bottleneck and a single point of failure for the application logic itself. If the single EC2 instance crashes or is overwhelmed, these services won't keep the core application running.\n*   **Incorrect (D):** Converting to a larger instance type (vertical scaling) is a temporary and limited solution. It increases capacity but does not provide high availability (it's still a single point of failure) nor the elastic scalability needed for unpredictable peak loads. It also tends to be less cost-effective than horizontal scaling with smaller instances. CloudWatch monitoring is essential, but it's a tool for observation, not a direct architectural solution to scalability or availability.\n\n---\n\n### Question 2: Terraform Script (Intermediate Level)\n\n**Question:**\nA DevOps team needs to deploy several EC2 instances for different application components across multiple environments (e.g., `dev-webapp`, `dev-batch`, `prod-webapp`, `prod-batch`). They want to define a common EC2 configuration once and create instances using a `for_each` loop based on a map of desired instances, ensuring each instance gets a unique and descriptive name.\n\nGiven the following `locals` block:\n\n```terraform\nlocals {\n  instance_configs = {\n    \"dev-webapp\"  = { ami = \"ami-0abcdef1234567890\", instance_type = \"t3.micro\" },\n    \"dev-batch\"   = { ami = \"ami-0abcdef1234567890\", instance_type = \"t3.small\" },\n    \"prod-webapp\" = { ami = \"ami-0fedcba9876543210\", instance_type = \"t3.medium\" },\n  }\n}\n```\n\nWhich of the following Terraform `resource` blocks correctly creates the EC2 instances with unique names and applies the specified configurations, using `for_each`?\n\n**Answer Options:**\nA.\n```terraform\nresource \"aws_instance\" \"app_server\" {\n  count         = length(local.instance_configs)\n  ami           = local.instance_configs[count.index].ami\n  instance_type = local.instance_configs[count.index].instance_type\n  tags = {\n    Name = \"${keys(local.instance_configs)[count.index]}\"\n  }\n}\n```\nB.\n```terraform\nresource \"aws_instance\" \"app_server\" {\n  for_each      = local.instance_configs\n  ami           = each.value.ami\n  instance_type = each.value.instance_type\n  tags = {\n    Name = each.key\n  }\n}\n```\nC.\n```terraform\nresource \"aws_instance\" \"app_server\" {\n  for_each      = values(local.instance_configs)\n  ami           = each.value.ami\n  instance_type = each.value.instance_type\n  tags = {\n    Name = each.key\n  }\n}\n```\nD.\n```terraform\nresource \"aws_instance\" \"app_server\" {\n  for_each      = local.instance_configs\n  ami           = local.instance_configs[each.key].ami\n  instance_type = local.instance_configs[each.key].instance_type\n  tags = {\n    Name = each.value\n  }\n}\n```\n\n**Correct Answer:** B\n\n**Explanation:**\n*   **Correct (B):** This option correctly uses `for_each` with the `local.instance_configs` map. When iterating over a map, `each.key` provides the map key (e.g., \"dev-webapp\"), which is perfect for the `Name` tag. `each.value` provides the corresponding map value (the object containing `ami` and `instance_type`), allowing direct access to `each.value.ami` and `each.value.instance_type`. This is the most idiomatic and correct way to achieve the desired outcome with `for_each`.\n*   **Incorrect (A):** This uses `count` instead of `for_each`. While `count` can create multiple resources, accessing map elements using `count.index` (e.g., `local.instance_configs[count.index]`) is problematic because map keys are strings, not integers. Additionally, relying on `keys(local.instance_configs)[count.index]` for naming is fragile because the order of map keys is not guaranteed, making resource addressing unstable if the map changes. `for_each` is preferred when the keys themselves are meaningful and unique identifiers.\n*   **Incorrect (C):** `values(local.instance_configs)` returns a list of the map's values. When `for_each` iterates over a list, `each.key` becomes the numeric index (0, 1, 2, ...), not the desired string identifier (e.g., \"dev-webapp\"). Therefore, `tags = { Name = each.key }` would result in numeric names instead of the descriptive names defined in the map keys.\n*   **Incorrect (D):** The lines `ami = local.instance_configs[each.key].ami` and `instance_type = local.instance_configs[each.key].instance_type` are redundant; `each.value.ami` and `each.value.instance_type` are cleaner and more direct as `each.value` already holds the object for the current iteration. More critically, `tags = { Name = each.value }` would attempt to assign the *entire object* (`{ ami = \"...\", instance_type = \"...\" }`) as the value for the `Name` tag, which is not a string and would cause a Terraform error. The `Name` tag expects a string value, which should be `each.key`.\n\n---\n\n### Question 3: Python Programming (Advanced Level)\n\n**Question:**\nConsider the following Python code snippet:\n\n```python\ndef repeater(n):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            results = []\n            for _ in range(n):\n                results.append(func(*args, **kwargs))\n            return results\n        return wrapper\n    return decorator\n\n@repeater(2)\ndef greet(name):\n    return f\"Hello, {name}!\"\n\n@repeater(3)\ndef calculate_sum(a, b):\n    return a + b\n\nprint(greet(\"Alice\"))\nprint(calculate_sum(10, 20))\n```\n\nWhat will be the output of this program?\n\n**Answer Options:**\nA.\n```\nHello, Alice!\n30\n```\nB.\n```\n['Hello, Alice!']\n[30]\n```\nC.\n```\n['Hello, Alice!', 'Hello, Alice!']\n[30, 30, 30]\n```\nD.\n```\nHello, Alice!\nHello, Alice!\n30\n30\n30\n```\n\n**Correct Answer:** C\n\n**Explanation:**\n*   **Correct (C):** The `repeater` function is a *decorator factory*. When `@repeater(n)` is applied, it first calls `repeater(n)`, which returns the `decorator` function. This `decorator` then takes the decorated function (e.g., `greet`) and returns the `wrapper` function.\n    *   For `greet(\"Alice\")`: The decorator factory is called with `n=2`. The `wrapper` function will execute `greet(\"Alice\")` twice. Each call returns `\"Hello, Alice!\"`, which is appended to the `results` list. Finally, `['Hello, Alice!', 'Hello, Alice!']` is returned by the `wrapper` and printed.\n    *   For `calculate_sum(10, 20)`: The decorator factory is called with `n=3`. The `wrapper` function will execute `calculate_sum(10, 20)` thrice. Each call returns `30` (`10 + 20`), which is appended to the `results` list. Finally, `[30, 30, 30]` is returned by the `wrapper` and printed.\n*   **Incorrect (A):** This output would occur if the decorated functions were only executed once, or if the `wrapper` function incorrectly returned only the last result, which contradicts the `for` loop and `results.append` logic.\n*   **Incorrect (B):** This output implies that `n` was effectively 1 for both calls, or that the `wrapper` only collected a single result, which is incorrect given the `n` values (2 and 3) passed to the `repeater` factory.\n*   **Incorrect (D):** This output would occur if the `wrapper` function printed each individual result inside its loop, rather than collecting them into a list and returning the list for the external `print()` calls to display. The `wrapper` builds a list and returns it, and the `print()` statement outside the decorator then prints that list."
}

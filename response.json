{
  "timestamp": "2026-02-08 09:29:06 UTC",
  "response": "Here are three multiple-choice questions designed to meet your specifications:\n\n---\n\n### **1. AWS Architect (Intermediate Level)**\n\n**Question:** A company is deploying a new customer-facing web application on AWS that requires high availability, automatic scaling based on traffic, and a relational database backend that must also be highly available and perform well under load. All data, especially customer information, must be encrypted at rest and in transit. Which AWS architecture best meets these requirements?\n\nA. An Elastic Load Balancer (ELB) distributing traffic to a single EC2 instance, connected to a single Amazon RDS instance in a public subnet.\nB. An Application Load Balancer (ALB) distributing traffic across an Auto Scaling Group of EC2 instances deployed across multiple Availability Zones, backed by an Amazon RDS Multi-AZ instance deployed in private subnets.\nC. An Amazon CloudFront distribution caching content from S3, with AWS Lambda functions for backend logic and Amazon DynamoDB for data storage.\nD. Direct access to EC2 instances provisioned in a public subnet with an Auto Scaling Group, using an Amazon RDS Single-AZ instance in a private subnet.\n\n**Correct Answer: B**\n\n**Explanation:**\n*   **A is incorrect:** A single EC2 instance and a single RDS instance do not provide high availability or automatic scaling. Placing RDS in a public subnet is a significant security risk.\n*   **B is correct:**\n    *   **Application Load Balancer (ALB):** Provides intelligent traffic routing and is ideal for HTTP/HTTPS traffic of a web application.\n    *   **Auto Scaling Group of EC2 instances across multiple AZs:** Ensures high availability (if one AZ fails, others are available) and automatic scaling of compute resources based on demand.\n    *   **Amazon RDS Multi-AZ instance in private subnets:** Provides high availability for the relational database (automatic failover to a standby instance in another AZ), performance under load, and keeps the database secure from direct internet access. Encryption at rest is a standard feature for RDS, and in-transit encryption is configurable.\n*   **C is incorrect:** This is a serverless architecture using DynamoDB (NoSQL), which does not meet the \"relational database\" requirement. While highly scalable, it's a different architectural pattern.\n*   **D is incorrect:** Direct access to EC2 instances in a public subnet is a security best practice violation. An RDS Single-AZ instance does not provide high availability for the database, failing the requirement.\n\n---\n\n### **2. Terraform Script (Intermediate Level)**\n\n**Question:** You need to provision multiple EC2 instances based on the `instance_configs` variable defined below. Each instance should have a unique `Name` tag corresponding to its specific `name_tag` value, and use its specific `ami_id` and `instance_type`.\n\n```terraform\nvariable \"instance_configs\" {\n  type = map(object({\n    ami_id        = string\n    instance_type = string\n    name_tag      = string\n  }))\n  default = {\n    \"webserver-01\" = { ami_id = \"ami-0abcdef1234567890\", instance_type = \"t2.micro\", name_tag = \"WebServerA\" },\n    \"appserver-01\" = { ami_id = \"ami-0fedcba9876543210f\", instance_type = \"t3.small\", name_tag = \"AppServerB\" },\n    \"dbserver-01\"  = { ami_id = \"ami-0123456789abcdef0\", instance_type = \"m5.large\", name_tag = \"DatabaseC\" },\n  }\n}\n```\n\nWhich Terraform `aws_instance` resource block correctly uses `for_each` to achieve this?\n\nA.\n```terraform\nresource \"aws_instance\" \"servers\" {\n  for_each      = var.instance_configs\n  ami           = each.value.ami_id\n  instance_type = each.value.instance_type\n  tags = {\n    Name = each.value.name_tag\n  }\n}\n```\n\nB.\n```terraform\nresource \"aws_instance\" \"servers\" {\n  count         = length(var.instance_configs)\n  ami           = values(var.instance_configs)[count.index].ami_id\n  instance_type = values(var.instance_configs)[count.index].instance_type\n  tags = {\n    Name = values(var.instance_configs)[count.index].name_tag\n  }\n}\n```\n\nC.\n```terraform\nresource \"aws_instance\" \"servers\" {\n  for_each      = var.instance_configs\n  ami           = each.ami_id\n  instance_type = each.instance_type\n  tags = {\n    Name = each.name_tag\n  }\n}\n```\n\nD.\n```terraform\nresource \"aws_instance\" \"servers\" {\n  for_each      = toset(keys(var.instance_configs))\n  ami           = var.instance_configs[each.value].ami_id\n  instance_type = var.instance_configs[each.value].instance_type\n  tags = {\n    Name = var.instance_configs[each.value].name_tag\n  }\n}\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A is correct:** When `for_each` is used with a map, `each.key` refers to the map's key (e.g., \"webserver-01\"), and `each.value` refers to the object associated with that key (e.g., `{ ami_id = ..., instance_type = ..., name_tag = ... }`). This allows direct and clear access to all required attributes for each instance.\n*   **B is incorrect:** This option uses `count` instead of `for_each` as explicitly requested in the question. While `count` can be used to create multiple resources, `for_each` is generally preferred when creating distinct resources from a map or set where each resource has unique, identifier-based properties. Using `values(var.instance_configs)[count.index]` relies on the order of map values, which is not guaranteed to be consistent across Terraform runs or versions.\n*   **C is incorrect:** This option misunderstands the context of `each` when `for_each` is used with a map. `each` itself is not the object; it's a structural element where `each.key` is the map key and `each.value` is the corresponding map value (object in this case). Therefore, `each.ami_id` is invalid; it should be `each.value.ami_id`.\n*   **D is incorrect:** This option iterates over a `set` of map keys (`toset(keys(var.instance_configs))`). In this context, `each.key` and `each.value` would both refer to the string key (e.g., \"webserver-01\"). While `var.instance_configs[each.value].ami_id` would correctly resolve the values, it's less idiomatic than directly iterating over the map using `for_each = var.instance_configs` and leveraging `each.value` for direct access to the object properties.\n\n---\n\n### **3. Python Programming (Advanced Level)**\n\n**Question:** You need to write a Python generator function `primes_up_to(n)` that yields all prime numbers less than or equal to `n`. Your solution should be efficient for reasonably large `n` (e.g., up to 10^5) and should *not* use any external libraries beyond Python's standard built-in functions. Which of the following implementations correctly and efficiently generates prime numbers using a generator?\n\nA.\n```python\ndef primes_up_to(n):\n    if n < 2:\n        return\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, int(n**0.5) + 1):\n        if is_prime[p]:\n            for multiple in range(p*p, n + 1, p):\n                is_prime[multiple] = False\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            yield p\n```\n\nB.\n```python\ndef primes_up_to(n):\n    def is_prime_trial(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    for num in range(2, n + 1):\n        if is_prime_trial(num):\n            primes.append(num)\n    return primes\n```\n\nC.\n```python\ndef primes_up_to(n):\n    if n < 2:\n        return\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, n + 1): # Inefficient loop range for marking multiples\n        if is_prime[p]:\n            for multiple in range(p * 2, n + 1, p): # Starts marking from p*2 instead of p*p\n                is_prime[multiple] = False\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            yield p\n```\n\nD.\n```python\ndef primes_up_to(n):\n    if n < 2:\n        yield from []\n        return\n    \n    known_primes = [2]\n    yield 2\n    for num in range(3, n + 1, 2): # Only checks odd numbers\n        is_current_prime = True\n        for p in known_primes:\n            if p * p > num:\n                break\n            if num % p == 0:\n                is_current_prime = False\n                break\n        if is_current_prime:\n            known_primes.append(num)\n            yield num\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A is correct:** This implementation uses the Sieve of Eratosthenes algorithm, which is highly efficient for finding all primes up to a given limit (time complexity approximately O(N log log N)). It correctly initializes a boolean array, marks multiples starting from `p*p` (an important optimization), and then iterates through the array to `yield` prime numbers, making it a true generator.\n*   **B is incorrect:** This function uses a trial division method (`is_prime_trial`) for each number, which is significantly less efficient than the Sieve of Eratosthenes (time complexity O(N * sqrt(N))). Additionally, it returns a *list* of primes, not a *generator*, meaning it will build the entire list in memory before returning, which can be memory-intensive for large `n`.\n*   **C is incorrect:** This option attempts to implement the Sieve of Eratosthenes but contains two critical inefficiencies. The outer loop `for p in range(2, n + 1)` iterates up to `n`, while the Sieve only needs to iterate up to `sqrt(n)` for marking multiples. More importantly, the inner loop `for multiple in range(p * 2, n + 1, p)` starts marking multiples from `p * 2`. The optimization for the Sieve is to start marking from `p * p`, as all smaller multiples (`p * 2`, `p * 3`, ..., `p * (p-1)`) would have already been marked by smaller primes. These inefficiencies make it slower than the optimal Sieve.\n*   **D is incorrect:** This is a variant of trial division optimized for odd numbers and reusing already found primes. While it is a generator and better than simple trial division, it's still less efficient than the Sieve of Eratosthenes for generating all primes up to `n` because it involves repeated division checks for each potential prime, unlike the Sieve which performs a single pass to mark multiples. The Sieve's O(N log log N) is superior to this approach's approximate O(N * sqrt(N)/log(N))."
}

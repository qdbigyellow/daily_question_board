{
  "timestamp": "2026-02-14 09:29:21 UTC",
  "response": "Here are three multiple-choice questions designed to meet your specifications:\n\n---\n\n### 1. AWS Architect (Intermediate Level)\n\n**Question:**\nA critical web application is currently deployed on AWS using EC2 instances behind an Application Load Balancer (ALB) and an RDS PostgreSQL database, all within a single Availability Zone (AZ). The company needs to enhance its architecture to ensure high availability and fault tolerance across multiple AZs *within the same region*, while also considering cost-effectiveness. Which of the following architectural changes best addresses these requirements?\n\n**Answer Options:**\nA. Configure the existing ALB to distribute traffic to EC2 instances launched across multiple AZs, and enable Multi-AZ deployment for the RDS PostgreSQL instance.\nB. Deploy an identical application stack (ALB, EC2, RDS) in a different AWS region and use Amazon Route 53 with failover routing policies.\nC. Migrate the application to AWS Lambda and Amazon Aurora Serverless, ensuring all services are inherently multi-AZ and scale automatically.\nD. Create an EC2 Auto Scaling Group with launch configurations specifying instances in multiple AZs, and continuously back up the RDS database to S3 for restoration in another AZ.\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A. Correct.** This option represents the most direct, cost-effective, and standard way to achieve multi-AZ high availability within a single AWS region for the described architecture. An ALB can natively distribute traffic across EC2 instances in multiple AZs. Enabling Multi-AZ for RDS PostgreSQL provides synchronous replication to a standby instance in another AZ and automatic failover, ensuring database resilience without requiring manual intervention.\n*   **B. Incorrect.** Deploying an identical stack in a different AWS region with Route 53 failover is a strategy for *cross-region disaster recovery*, not high availability *within the same region*. It is significantly more complex and expensive than a multi-AZ setup in a single region.\n*   **C. Incorrect.** While migrating to serverless services like Lambda and Aurora Serverless can provide inherent high availability and scalability, it constitutes a complete re-architecture/re-platforming effort, which is a much larger undertaking than simply \"enhancing its architecture\" for multi-AZ within the existing paradigm. The question implies an evolution of the current stack.\n*   **D. Incorrect.** While using an EC2 Auto Scaling Group across multiple AZs is an excellent practice for EC2 instance high availability, continuously backing up RDS to S3 and restoring it in another AZ is a *disaster recovery* strategy, not a *high-availability* solution with automatic failover for the database. RDS Multi-AZ (Option A) is the specific feature for automated database failover within a region.\n\n---\n\n### 2. Terraform Script (Intermediate Level)\n\n**Question:**\nA Terraform configuration is being developed to provision an EC2 instance and a new AWS Security Group. The EC2 instance must be associated with this newly created security group, and Terraform must correctly handle the dependency, ensuring the security group exists before the instance attempts to associate with it. Assume valid `vpc_id` and `ami_id` variables are defined and available. Which of the following code snippets correctly and idiomatically associates the EC2 instance with the `web_sg` security group?\n\n**Answer Options:**\n\nA.\n```terraform\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg_example\"\n  description = \"Allow HTTP inbound traffic\"\n  vpc_id      = var.vpc_id\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = var.ami_id\n  instance_type = \"t2.micro\"\n  vpc_security_group_ids = [aws_security_group.web_sg.id]\n}\n```\n\nB.\n```terraform\nresource \"aws_instance\" \"web\" {\n  ami           = var.ami_id\n  instance_type = \"t2.micro\"\n  security_groups = [\"web_sg_example\"]\n}\n\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg_example\"\n  description = \"Allow HTTP inbound traffic\"\n  vpc_id      = var.vpc_id\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\nC.\n```terraform\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg_example\"\n  description = \"Allow HTTP inbound traffic\"\n  vpc_id      = var.vpc_id\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = var.ami_id\n  instance_type = \"t2.micro\"\n  security_groups = [aws_security_group.web_sg.name]\n}\n```\n\nD.\n```terraform\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg_example\"\n  description = \"Allow HTTP inbound traffic\"\n  vpc_id      = var.vpc_id\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = var.ami_id\n  instance_type = \"t2.micro\"\n  vpc_security_group_ids = [aws_security_group.web_sg.id]\n  depends_on = [aws_security_group.web_sg]\n}\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A. Correct.** This is the idiomatic and correct way to associate an EC2 instance with a security group created within the same Terraform configuration. By referencing `aws_security_group.web_sg.id` in the `vpc_security_group_ids` argument of the `aws_instance` resource, Terraform automatically establishes an *implicit dependency*. This ensures that the `aws_security_group.web_sg` resource is fully created and its `id` attribute is available before the `aws_instance.web` resource is provisioned.\n*   **B. Incorrect.** The `security_groups` argument in `aws_instance` is primarily for EC2-Classic, or for referencing existing security groups by name in a default VPC. For VPC security groups created in the same configuration, the `vpc_security_group_ids` argument, which expects a list of security group IDs, should be used.\n*   **C. Incorrect.** Similar to option B, `security_groups` is the wrong attribute for VPC security groups defined in-config. Even if `vpc_security_group_ids` were used, referencing `aws_security_group.web_sg.name` is incorrect; it requires the actual ID of the security group.\n*   **D. Incorrect.** While this code will functionally work, it is not considered idiomatic Terraform. The `depends_on` argument is used for *explicit* dependencies when Terraform cannot infer them implicitly. In this case, `aws_instance.web` already has an implicit dependency on `aws_security_group.web_sg` because it references `aws_security_group.web_sg.id`. Adding an explicit `depends_on` is redundant and adds unnecessary verbosity without providing additional benefit.\n\n---\n\n### 3. Python Programming (Advanced Level)\n\n**Question:**\nYou need to implement a Python decorator called `retry` that can be applied to functions. This decorator should automatically re-execute the decorated function up to a specified number of times if it raises a `ValueError`. The decorator must accept an optional `max_attempts` argument, defaulting to 3. If all attempts fail, the *last* `ValueError` should be re-raised. Which of the following implementations correctly defines and uses this `retry` decorator?\n\n**Answer Options:**\n\nA.\n```python\ndef retry(max_attempts=3):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            last_exception = None\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except ValueError as e:\n                    last_exception = e\n                    attempts += 1\n                except Exception: # This line catches other exceptions and re-raises immediately\n                    raise\n            if last_exception:\n                raise last_exception\n        return wrapper\n    return decorator\n```\n\nB.\n```python\ndef retry(func):\n    def wrapper(max_attempts=3, *args, **kwargs):\n        attempts = 0\n        last_exception = None\n        while attempts < max_attempts:\n            try:\n                return func(*args, **kwargs)\n            except ValueError as e:\n                last_exception = e\n                attempts += 1\n        if last_exception:\n            raise last_exception\n    return wrapper\n```\n\nC.\n```python\ndef retry(max_attempts=3):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except ValueError:\n                    pass\n            # If loop finishes, function silently failed, no re-raise\n            return None\n        return wrapper\n    return decorator\n```\n\nD.\n```python\ndef retry(max_attempts=3):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts < max_attempts:\n                # Missing try-except block\n                result = func(*args, **kwargs)\n                return result # Will exit after first attempt regardless\n                attempts += 1 # Unreachable code\n            # No error handling for ValueError\n        return wrapper\n    return decorator\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A. Correct.** This implementation correctly defines a decorator that accepts arguments (`max_attempts`) by using a triple-nested function structure (`retry` -> `decorator` -> `wrapper`). The `wrapper` function contains the retry logic: it attempts to execute `func`, catches `ValueError`, increments `attempts`, and stores the `last_exception`. If `max_attempts` is reached, it re-raises the `last_exception`. The `except Exception: raise` block is a minor deviation as the question only specified `ValueError`, but it ensures any *other* unforeseen exceptions are not accidentally retried and are instead propagated immediately, which is generally good practice for a targeted retry decorator. (For strict adherence to only `ValueError`, the `except Exception` block could be removed).\n*   **B. Incorrect.** This implementation is for a decorator that *doesn't* take arguments. If you tried to use it with `@retry(max_attempts=2)`, Python would raise an error because `retry` is expecting `func` as its first argument immediately, not `max_attempts`. `max_attempts` is defined as an argument to the *wrapper* function, meaning it would have to be passed when calling the decorated function, not when decorating it.\n*   **C. Incorrect.** This decorator successfully retries, but it violates the requirement that the *last* `ValueError` should be re-raised if all attempts fail. The `except ValueError: pass` clause silently suppresses all `ValueError` exceptions. If all attempts fail, the `wrapper` function will simply return `None` (implicitly) without indicating that the function ultimately failed.\n*   **D. Incorrect.** This implementation completely misses the `try-except` block, which is fundamental for catching errors and retrying. The `func(*args, **kwargs)` call is made without any error handling. Additionally, `return result` will cause the `wrapper` to exit after the very first attempt, regardless of success or failure, making `attempts += 1` unreachable and defeating the retry logic."
}

{
  "timestamp": "2026-02-04 09:42:33 UTC",
  "response": "Here are three multiple-choice questions, each tailored to the specified requirements:\n\n---\n\n### Question 1: AWS Architect (Intermediate Level)\n\nA growing e-commerce company needs to host its critical 3-tier web application on AWS. The application consists of web servers, application servers, and a PostgreSQL database. The primary goal is to achieve high availability within a single region and ensure disaster recovery (DR) capabilities with an RTO (Recovery Time Objective) of less than 4 hours and an RPO (Recovery Point Objective) of less than 1 hour in case of a regional outage.\n\nWhich AWS architecture pattern best meets these requirements?\n\nA. Deploy all web, app servers, and the PostgreSQL database in a single Availability Zone (AZ). Implement daily backups of the database to Amazon S3, and for DR, replicate S3 backups to another region using S3 Cross-Region Replication.\nB. Deploy web and app servers across multiple AZs using Auto Scaling Groups behind an Application Load Balancer (ALB). Use a Multi-AZ Amazon RDS for PostgreSQL. For DR, rely on regular database snapshots replicated to a different region, restoring from the snapshot if a regional outage occurs.\nC. Deploy web and app servers across multiple AZs using Auto Scaling Groups behind an Application Load Balancer (ALB). Use a Multi-AZ Amazon RDS for PostgreSQL. For DR, configure an Amazon RDS Cross-Region Read Replica in a different region and automate the replication of application artifacts (e.g., AMIs, code) to the DR region, with a defined manual failover procedure.\nD. Deploy web and app servers in a single AZ, but distribute traffic using Amazon Route 53 with health checks. Use a Multi-AZ Amazon RDS for PostgreSQL. For DR, configure an Amazon RDS Cross-Region Read Replica and use AWS Global Accelerator to redirect user traffic to the DR region instantly.\n\n**Correct Answer: C**\n\n**Explanation:**\n*   **A. Incorrect:** Deploying all components in a single AZ provides no resilience against AZ failures, which is a fundamental requirement for high availability. Relying on S3 backups for RDS restoration in a DR scenario would likely exceed the 4-hour RTO.\n*   **B. Incorrect:** While distributing web/app servers across AZs with ALB and using Multi-AZ RDS ensures high availability within a region, relying solely on restoring from database snapshots for regional DR is problematic. Creating a new RDS instance from a snapshot in another region can be time-consuming and may exceed the 4-hour RTO, especially for large databases. The RPO might also be missed if snapshot frequency isn't aligned with the 1-hour RPO.\n*   **C. Correct:**\n    *   **High Availability (within region):** Deploying web/app servers across multiple AZs with Auto Scaling Groups behind an ALB ensures fault tolerance against AZ failures for the application layer. Multi-AZ RDS provides synchronous replication and automatic failover for the database within the primary region, handling AZ outages transparently.\n    *   **Disaster Recovery (cross-region):** An Amazon RDS Cross-Region Read Replica is crucial for meeting strict RPO (less than 1 hour) and RTO (less than 4 hours) requirements. It maintains an up-to-date copy of the database in the DR region that can be quickly promoted to a standalone database instance. Replicating application artifacts ensures that the application layer can also be quickly deployed and brought online in the DR region. A manual failover procedure is common for intermediate-level DR strategies.\n*   **D. Incorrect:** Deploying web and app servers in a *single* AZ defeats the purpose of high availability and makes the application vulnerable to single points of failure within the primary region. Route 53 with health checks and Global Accelerator help with traffic routing but do not solve the underlying problem of having an active, resilient application stack or data available in the DR region if the primary region fails. While the Cross-Region Read Replica is good for data RPO/RTO, the application layer itself needs to be available in the DR region.\n\n---\n\n### Question 2: Terraform Script (Intermediate Level)\n\nYou need to provision four identical EC2 instances in AWS using Terraform. Each instance should have a unique `Name` tag, generated by appending its index (0, 1, 2, 3) to the string \"backend-server-\". For example, `backend-server-0`, `backend-server-1`, etc.\n\nWhich of the following Terraform code snippets correctly uses the `count` meta-argument to achieve this?\n\nA.\n```terraform\nresource \"aws_instance\" \"app_backend\" {\n  count         = 4\n  ami           = \"ami-0abcdef1234567890\" # Example AMI ID, replace with a valid one\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"backend-server-${count.index}\"\n  }\n}\n```\n\nB.\n```terraform\nresource \"aws_instance\" \"app_backend\" {\n  instances     = [\"server-0\", \"server-1\", \"server-2\", \"server-3\"]\n  ami           = \"ami-0abcdef1234567890\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = each.key\n  }\n}\n```\n\nC.\n```terraform\nresource \"aws_instance\" \"app_backend\" {\n  for_each      = toset([\"0\", \"1\", \"2\", \"3\"])\n  ami           = \"ami-0abcdef1234567890\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"backend-server-${each.key}\"\n  }\n}\n```\n\nD.\n```terraform\nresource \"aws_instance\" \"app_backend\" {\n  count         = [\"0\", \"1\", \"2\", \"3\"]\n  ami           = \"ami-0abcdef1234567890\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"backend-server-${count.index}\"\n  }\n}\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n*   **A. Correct:** This snippet correctly uses the `count` meta-argument to specify that 4 instances should be created. Inside the resource block, `count.index` provides the current iteration's zero-based index (0, 1, 2, 3), which is then correctly interpolated into the `Name` tag string.\n*   **B. Incorrect:** `instances` is not a valid meta-argument for a resource block. The `each.key` variable is used with the `for_each` meta-argument, not `instances`.\n*   **C. Incorrect:** This snippet uses the `for_each` meta-argument, not `count`, which goes against the specific instruction in the question. While `for_each` could achieve a similar outcome with `each.value` or `each.key` depending on the map/set, the question specifically asks for `count`.\n*   **D. Incorrect:** The `count` meta-argument expects an integer value representing the number of times the resource should be created, not a list of strings. Passing a list here would result in a Terraform configuration error.\n\n---\n\n### Question 3: Python Programming (Advanced Level)\n\nYou need to create a Python decorator, implemented as a class, that counts and logs the number of times the decorated function is called. Each decorated function should maintain its *own independent call count*.\n\nWhich of the following implementations correctly achieves this?\n\nA.\n```python\nclass CallCounter:\n    def __init__(self, func):\n        self.func = func\n        self.calls = 0 # Instance-specific counter\n\n    def __call__(self, *args, **kwargs):\n        self.calls += 1\n        print(f\"'{self.func.__name__}' called {self.calls} times.\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef calculate_sum(a, b):\n    return a + b\n\n@CallCounter\ndef calculate_product(a, b):\n    return a * b\n\ncalculate_sum(1, 2)\ncalculate_sum(3, 4)\ncalculate_product(2, 3)\n```\n\nB.\n```python\nclass CallCounter:\n    def __init__(self):\n        self.calls = 0 # Instance-specific counter\n\n    def __call__(self, func):\n        def wrapper(*args, **kwargs):\n            self.calls += 1\n            print(f\"'{func.__name__}' called {self.calls} times.\")\n            return func(*args, **kwargs)\n        return wrapper\n\n@CallCounter() # Note the parentheses\ndef calculate_sum(a, b):\n    return a + b\n\ncalculate_sum(1, 2)\n```\n\nC.\n```python\ndef CallCounter(func):\n    calls = 0 # Enclosed scope counter\n\n    def wrapper(*args, **kwargs):\n        nonlocal calls\n        calls += 1\n        print(f\"'{func.__name__}' called {calls} times.\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@CallCounter\ndef calculate_sum(a, b):\n    return a + b\n\ncalculate_sum(1, 2)\ncalculate_sum(3, 4)\n```\n\nD.\n```python\nclass CallCounter:\n    total_calls = 0 # Class-level counter\n\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        CallCounter.total_calls += 1\n        print(f\"'{self.func.__name__}' called {CallCounter.total_calls} times.\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef calculate_sum(a, b):\n    return a + b\n\n@CallCounter\ndef calculate_product(a, b):\n    return a * b\n\ncalculate_sum(1, 2)\ncalculate_product(2, 3)\n```\n\n**Correct Answer: A**\n\n**Explanation:**\n\n*   **A. Correct:** This implementation correctly uses a class-based decorator.\n    *   When `@CallCounter` is used, the `CallCounter` class is instantiated, and its `__init__` method receives the `calculate_sum` function (or `calculate_product` function) as `func`.\n    *   An instance variable `self.calls` is initialized to `0` *for each decorated function*. This ensures that `calculate_sum` and `calculate_product` each have their own independent call count.\n    *   The `__call__` method makes instances of `CallCounter` callable. When `calculate_sum()` is invoked, it's actually the `__call__` method of the `CallCounter` instance associated with `calculate_sum` that gets executed, incrementing its `self.calls` and then executing the original function.\n    *   This design properly encapsulates the state (the call count) within each decorator instance, fulfilling the requirement for independent counts.\n\n*   **B. Incorrect:** This is a class-based *decorator factory* pattern. When `@CallCounter()` is used, `CallCounter()` first creates an instance of `CallCounter`. Then, this instance's `__call__` method is expected to receive the function `calculate_sum` to be decorated. While this pattern is valid for decorators that accept arguments (e.g., `@CallCounter(param=value)`), it doesn't align with the standard application of `@CallCounter` without parentheses if `__init__` is intended to receive the function directly. Furthermore, the question asks for `@CallCounter` (without parentheses in the examples for A and D), implying the direct application of the class. If applied as `@CallCounter`, the class itself would be called with `func` as the argument, and it doesn't have a `__call__` method that acts as the decorator function directly in this structure.\n\n*   **C. Incorrect:** This is a *function-based decorator*, not a class-based decorator, failing to meet a key specification of the question. While it correctly uses `nonlocal` to maintain an independent count for each decorated function, it does not use a class.\n\n*   **D. Incorrect:** This implementation uses a *class variable* `total_calls`. This means that `total_calls` is shared across all instances of `CallCounter`. If both `calculate_sum` and `calculate_product` are decorated, they would both increment the *same* `CallCounter.total_calls` variable, resulting in a single global count rather than independent counts for each function. The output `calculate_sum(1, 2)` would print \"called 1 times.\" and `calculate_product(2, 3)` would then print \"called 2 times.\" even on its first call, which violates the requirement for independent counts."
}
